# This is my first blog
# START
## 数据处理考虑：
  0. sqlalchemy_model 在相应 model 增加该列，修改数据库
  1. batch load 数据
  2. 读取数据给算法
  3. 前端读取数据展现

## branch: dev-mongo

## mysql tables
* cross_area_time +routeTypeCode
* subroute_vph +routeTypeCode
* deliveries_history_convex +routeTypeCode
* navigation_cross_time +routeTypeCode
* route_sol_running +wave(已在dev上改好)(batch不写这张表，只需测试算法运行即可)

routeType 只分两种，NORMAL 和 OVERNIGHT，DROPOFF LoadingSOP暂时不考虑，SHIFT_1和SHIFT_2都是NORMAL的一部分。FRESH暂时认为是OVERNIGHT的一部分。

## e.g.:
cross_area_time
  1. 在dev上改表
```sql
    ALTER TABLE `cross_area_time`
    ADD COLUMN `routeTypeCode` varchar(30) DEFAULT NULL COMMENT '배송 타입 정보 (NORMAL, DROP_OFF)';
```
  2. sqlalchemy_model
```python
  class CrossAreaTime(Base):
    ......
    routeTypeCode = Column(String)
```
  3. load_data_into_db
`load_cross_area_time` 向下搜索并修改

  4. get_data_for_algorithm, get_data_for_UI and other function 
搜索所有读取cross_area_time的方法，并向下搜索修改。比如 `ga.get_cross_time(date=date, campid=campid)`。
    因为cross_area_time subroute_vph navigation_cross_time 都只是算法需要使用的数据，前端并不会展示，所以一般只会出现在get_data_for_algorithm，而 deliveries_history_convex table是hongyuan添加，他会更熟悉改表的写入与调用。

  5. 修改 apsch 中对数据获取的封装，比如其中的cross_area_time(today, campid) 方法需要改成 cross_area_time(today, campid, routeType)

  6. 每改完一张表后，测试
      a. batch 能否正常运行，
      b. 算法是否可以正常运行，算法拿到的数据是否是正确的数据。
    batch调用：apsch -> load_data 中的方法，以及 updateForUI.subroute_convex 
    算法调用：apsch -> get_output_sol 方法

## mongo table
* deliveries_history